[ "$OSTYPE" = "linux-gnueabi" ] && export PS1="    \[\033[0;33m\]\w\[\033[0;37m\] \[\033[0;32m\]Îµ\[\033[0;37m\]  "
[ "$OSTYPE" = "linux-gnu" ] && export PS1="    \[\033[0;33m\]\w\[\033[0;37m\] \[\033[0;32m\]Îž\[\033[0;37m\]  "
[[ $OSTYPE =~ ^darwin ]] && export PS1="    \[\033[0;33m\]\w\[\033[0;37m\] \[\033[0;35m\]É€\[\033[0;37m\]  "
[ "`whoami`" = "vgurdiga" ] && export PS1="    \[\033[0;33m\]\w\[\033[0;37m\] \[\033[1;33m\]Ï‰\[\033[0;37m\]  "

echo -n -e "\033]0;`whoami`@`hostname -f`\007"

# Cause the status of terminated background jobs to be reported immediately,
# rather than before printing the next primary prompt.
set -b

shopt -s globstar
shopt -s extglob

# If set, the history list is appended to the file named by the value of the
# HISTFILE variable when the shell exits, rather than overwriting the file.
shopt -s histappend

export HISTSIZE=100000
export HISTCONTROL=ignoredups
export HISTTIMEFORMAT='%Y-%m-%d %T '
export MAILCHECK=
export LC_CTYPE=en_US.UTF-8
export CLICOLOR=1
export LSCOLORS=GxFxCxDxBxegedabagaced
export EDITOR=vim
export MANWIDTH=80

# per-directory Bash history
function check_for_local_history {
	function main {
		if found_local_history_file; then
			use_history_file $PWD/.bash_history
		else
			use_history_file ~/.bash_history
		fi
	}

	function found_local_history_file {
		[ -e .bash_history ]
  	}

	function use_history_file {
		history -w
		history -c
		export HISTFILE=$1
		history -r
	}

	main
}

function changing_directory {
	function main {
		local last_command=`history 1`
		local last_command=${last_command:27} # this depends on HISTTIMEFORMAT

		is_cd_nothing || is_cd_something || is_a_cd_alias
	}

	function is_cd_nothing {
		[ ${#last_command} -eq 2 -a "${last_command:0:2}" = "cd" ]
	}

	function is_cd_something {
		[ ${#last_command} -gt 2 -a "${last_command:0:3}" = "cd " ]
	}

	function is_a_cd_alias {
		local cd_aliases=`alias | grep "='cd " | grep -E -o 'alias [a-z]+='`
		echo $cd_aliases | grep -F -q "alias $last_command="
	}

	main
}

function check_for_nvmrc {
	if [ -e .nvmrc ]; then
		export NVM_DIR="$HOME/.nvm"
		source "$NVM_DIR/nvm.sh"  # This loads nvm
		nvm use
	fi
}

function check_for_ruby_version {
	if [ -e .ruby-version ]; then
		source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
		rvm use
	fi
}

function check_for_dot_env {
	if [ -e .env ]; then
		source .env
		echo "Loaded environment variables from .env"
	fi
}

function do_my_checks {
	if ! changing_directory; then
		return
	fi

	check_for_local_history
	check_for_nvmrc
	check_for_ruby_version
	check_for_dot_env
}

function add_prompt_command {
	function main {
		if ! already_set; then
			if [ -z "$PROMPT_COMMAND" ]; then
				PROMPT_COMMAND="do_my_checks"
			else
				PROMPT_COMMAND="${PROMPT_COMMAND}; do_my_checks"
			fi
		fi
	}

	function already_set {
		grep -q check_for_local_history <<<$PROMPT_COMMAND
	}

	main
}

add_prompt_command

export RUBY_GC_MALLOC_LIMIT=90000000
export RUBY_GC_HEAP_FREE_SLOTS=200000

# brew
export PATH=/usr/local/sbin:/usr/local/bin:$PATH
export PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH"
export PATH="/usr/local/opt/grep/libexec/gnubin:$PATH"
export PATH="/usr/local/opt/gnu-sed/libexec/gnubin:$PATH"
export MANPATH="/usr/local/opt/coreutils/libexec/gnuman:$MANPATH"

# node
export PATH=./node_modules/.bin:$PATH

# go
export PATH=$PATH:~/go/bin

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

function get_make_completion_options {
	if [ -e Makefile ]; then
		make -pq |\
		grep -oP '^[a-zA-Z0-9_-]+(?=:)'
	fi
}

complete -W "`get_make_completion_options`" m

function pull() {
	if [ ! -d .git ]; then
		echo "Not a Git repo."
		return 1
	fi

	if [ $# -eq 0 ]; then
		# If there is a tracked branch only pull that one
		git status --short --branch |\
		head -1 |\
		grep -oP '\.{3}\K\S+' |\
		sed 's|/| |' |\
		xargs git pull
	else
		git pull "$@"
	fi
}

function q() {
	local wildcard="$1"
	shift
	local dirs="$@"

	local IGNORE_DIRS=".git"
	local DOT_FILE=".qignore"
	local EXCLUDE_DIR_CLAUSE=""

	if [ -f $DOT_FILE ]; then
		IGNORE_DIRS+=" "`cat "$DOT_FILE" | paste -sd " "`
	fi

	local IGNORE_DIRS_RE=${IGNORE_DIRS// /\|}

	for DIR in $IGNORE_DIRS; do
		EXCLUDE_DIR_CLAUSE+=" -path ./$DIR -prune -o"
	done

	find ${dirs:-.} $EXCLUDE_DIR_CLAUSE -name "$wildcard" \
		| grep -Pv "^./($IGNORE_DIRS_RE)$"
}

function aac2mp3() {
	aac_file=$1
	mp3_file=$(basename "$aac_file" .aac).mp3
	wav_file=/tmp/aac2mp3.wav
	ffmpeg -i "$aac_file" "$wav_file" && \
	ffmpeg -i "$wav_file" -acodec libmp3lame "$mp3_file" && \
	rm "$wav_file"
}

function f() {
	if [ "$#" -eq 0 ]; then
		echo 'Find what?'
		return 0
	fi

	local DOT_FILE=".grepignore"
	local MAX_LINE_LENGTH=$(($COLUMNS * 3))

	local IGNORE_DIRS=".git .svn node_modules bower_components"
	local IGNORE_FILES=".bash_history .viminfo"
	local EXCLUDE_DIR_CLAUSE=""
	local EXCLUDE_CLAUSE=""

	if [ -f $DOT_FILE ]; then
		IGNORE_DIRS+=" $(echo $(grep '/$' $DOT_FILE | sed 's|/$||'))"
		IGNORE_FILES+=" $(echo $(grep -v '/$' $DOT_FILE))"
	fi

	for DIR in $IGNORE_DIRS; do
		EXCLUDE_DIR_CLAUSE+=" --exclude-dir=$DIR"
	done

	for FILE in $IGNORE_FILES; do
		EXCLUDE_CLAUSE+=" --exclude=$FILE"
	done

	grep \
		--color=always \
		--line-number \
		--binary-files=without-match \
		--recursive \
		$EXCLUDE_CLAUSE \
		$EXCLUDE_DIR_CLAUSE "$@" \
		| cut -c -$MAX_LINE_LENGTH
}

function gif() {
	if [ "$#" -eq 0 ]; then
		echo 'Gif what?'
		return 0
	fi

	local input="$1"
	local filename="${input%.*}"

	ffmpeg -i "$input" -pix_fmt rgb24 -r 10 -f gif - | gifsicle --loopcount=forever --optimize=3 --delay=5 > "$filename.gif"
}

function inith() {
	if [ ! -e .bash_history ]; then
		touch .bash_history
	else
		echo ".bash_history already exists"
	fi
}

function initv() {
	local viminfo_config="set viminfo+=n.viminfo"
	if [ ! -e .vimrc ]; then
		echo "$viminfo_config" > .vimrc
	else
		if grep -F "set viminfo" .vimrc; then
			echo ".viminfo already configured"
		else
			echo "$viminfo_config" >> .vimrc
			echo ".viminfo configured"
		fi
	fi
}

function svgoo() {
	if [ "$#" -eq 0 ]; then
		echo 'Gimme an SVG file to optimize, please!'
		return 1
	fi

	if ! which -s svgo; then
		echo 'Iâ€™m not seeing your svgo executable...ðŸ¤”'
		return 2
	fi

	local file="$1"
	svgo --input="$file" --pretty
}

function is_interactive_shell() {
	# https://www.gnu.org/software/bash/manual/html_node/Is-this-Shell-Interactive_003f.html
	[[ "$-" =~ "i" ]]
}

if is_interactive_shell; then
	# fzf git branch name; use like this: git checkout ^g^b
	bind '"\C-g\C-b": "$(git branch -a | cut -c 3- | fzf)\e\C-e"'
fi

#fzf
export FZF_CTRL_T_COMMAND="fd --type f"

# yes, or maybe not?
# source /usr/local/etc/bash_completion

# Autocompletion of Make targets BEGIN

function _makefile_targets {
    local curr_arg;
    local targets;

    # Find makefile targets available in the current directory
    targets=''
    if [[ -e "$(pwd)/Makefile" ]]; then
        targets=$( \
            grep -oE '^[a-zA-Z0-9_-]+:' Makefile \
            | sed 's/://' \
            | tr '\n' ' ' \
        )
    fi

    # Filter targets based on user input to the bash completion
    curr_arg=${COMP_WORDS[COMP_CWORD]}
    COMPREPLY=( $(compgen -W "${targets[@]}" -- $curr_arg ) );
}
complete -F _makefile_targets make
complete -F _makefile_targets m

# Autocompletion of Make targets END

function hibp() {
	local password_hash=`read -s -p "Password: " p && echo -n $p | openssl sha1`
	local head=${password_hash:0:5}
	local tail=${password_hash:5}

	local tempfile=`mktemp`

	if curl https://api.pwnedpasswords.com/range/$head --output $tempfile; then
		if grep --ignore-case $tail $tempfile; then
			echo YEP;
		else
			echo NOPE
		fi
	fi
}

function log {
	local directory=~/Google\ Drive/log
	local filename="`date +%F-%H-%M`.txt"

	cp "$directory/template.txt" "$directory/$filename"
	cd "$directory"
	code --new-window "$filename" && exit
}

function think {
	code --new-window note.txt && exit
}

function skip {
	tail --lines +`expr $1 + 1`
}

function vimp {
	file=$1
	line_number=`expr "$file" : '.*:\([0-9]\+\)'`

	if [[ "$file" =~ :[0-9]*.*$ ]]; then
		file=${file/$BASH_REMATCH/}
		line_number=$BASH_REMATCH
		line_number=${line_number/:/}
		line_number=${line_number/[^0-9]*/}

		if [[ "$line_number" -ne "" ]]; then
			line_number="+$line_number"
		fi

		vim "$file" $line_number
	else
		vim "$@"
	fi
}

function source_location {
	shopt -s extdebug
	declare -F $1
	shopt -u extdebug
}
